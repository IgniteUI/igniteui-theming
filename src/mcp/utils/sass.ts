/**
 * Sass code generation utilities.
 *
 * This module provides low-level helpers for generating Sass code snippets.
 * These helpers are designed to be reusable across different code generators
 * (standalone tools and platform-specific theme generators).
 */

import { SHADE_LEVELS } from "../knowledge/index.js";
import {
	ALL_COLOR_SHADES,
	type ColorDefinition,
	type GrayDefinition,
	type Platform,
	type ThemeVariant,
} from "./types.js";

/**
 * Properly quote a font-family value for Sass.
 * Font stacks (containing commas) need to be wrapped in quotes
 * to preserve them as a single string value.
 *
 * Handles various input formats:
 * - `Roboto` -> `'Roboto'`
 * - `'Roboto'` -> `'Roboto'` (unchanged)
 * - `'Titillium Web', sans-serif` -> `"'Titillium Web', sans-serif"`
 * - `"Titillium Web", sans-serif` -> `'"Titillium Web", sans-serif'`
 */
export function quoteFontFamily(typeface: string): string {
	if (typeface.includes(",")) {
		// Font stack: wrap entire value in quotes to preserve as single string.
		// Use opposite quote type to avoid escaping inner quotes.
		const hasDoubleQuotes = typeface.includes('"');
		const hasSingleQuotes = typeface.includes("'");

		if (hasDoubleQuotes && !hasSingleQuotes) {
			// Inner double quotes -> wrap with single quotes
			return `'${typeface}'`;
		}
		// Inner single quotes or no quotes -> wrap with double quotes
		return `"${typeface}"`;
	}
	// Single font: add quotes if not already quoted
	if (typeface.startsWith("'") || typeface.startsWith('"')) {
		return typeface;
	}
	return `'${typeface}'`;
}

/**
 * Convert a name to a valid Sass variable name.
 *
 * Transforms input string to lowercase, replaces invalid characters with hyphens,
 * collapses multiple hyphens, and removes leading/trailing hyphens.
 *
 * @param name - The name to convert
 * @returns A valid Sass variable name (without $ prefix)
 * @throws Error if the input results in an empty variable name
 *
 * @example
 * toVariableName('My Theme') // 'my-theme'
 * toVariableName('DARK_THEME_v2') // 'dark-theme-v2'
 */
export function toVariableName(name: string): string {
	if (!name || !name.trim()) {
		throw new Error("Variable name cannot be empty");
	}

	const result = name
		.toLowerCase()
		.replace(/[^a-z0-9-]/g, "-")
		.replace(/-+/g, "-")
		.replace(/^-|-$/g, "");

	if (!result) {
		throw new Error(`Cannot create valid Sass variable name from: "${name}"`);
	}

	return result;
}

/**
 * Generate a comment header for generated Sass code.
 *
 * @param description - Description of what the code does
 * @returns Formatted Sass comment header
 */
export function generateHeader(description: string): string {
	return `// Generated by Ignite UI Theming MCP Server\n// ${description}`;
}

// ============================================================================
// LOW-LEVEL CODE GENERATION HELPERS
// These helpers generate reusable code snippets that can be composed by both
// standalone tools and platform-specific theme generators.
// ============================================================================

/**
 * Generate the Sass @use statement for the theming library.
 * Uses platform-specific import paths when platform is specified.
 *
 * @param platform - Target platform (angular or webcomponents)
 * @param licensed - Whether to use the licensed @infragistics package (Angular only, defaults to false)
 * @returns The appropriate @use statement for the platform
 */
export function generateUseStatement(
	platform?: Platform,
	licensed?: boolean,
): string {
	if (platform === "angular") {
		const packagePath = licensed
			? "@infragistics/igniteui-angular"
			: "igniteui-angular";
		return `@use "${packagePath}/theming" as *;`;
	}
	// Web Components, React, Blazor, or unspecified (always use igniteui-theming - it's free)
	return "@use 'igniteui-theming' as *;";
}

/**
 * Typography presets index path.
 * Imports through the index to get design-system-prefixed variables
 * (e.g., $material-type-scale, $indigo-type-scale).
 */
const TYPOGRAPHY_PRESETS_PATH = "igniteui-theming/sass/typography/presets";

/**
 * Elevations presets index path.
 * Imports through the index to get design-system-prefixed variables
 * (e.g., $material-elevations, $indigo-elevations).
 */
const ELEVATIONS_PRESETS_PATH = "igniteui-theming/sass/elevations/presets";

/**
 * Generate additional @use import statements for typography and/or elevation presets.
 *
 * For non-Angular platforms, preset variables like `$material-type-scale` and
 * `$material-elevations` are defined in separate sub-modules that must be
 * explicitly imported. Angular's `igniteui-angular/theming` re-exports all
 * presets, so no additional imports are needed.
 *
 * These imports use the presets index files which re-forward individual
 * design system modules with prefixed names (e.g., `$type-scale` becomes
 * `$material-type-scale` via `@forward './material' as material-*`).
 *
 * @param options - Configuration for which preset imports to include
 * @returns Array of @use statements (empty for Angular)
 */
export function generatePresetImports(options: {
	platform?: Platform;
	includeTypography?: boolean;
	includeElevations?: boolean;
}): string[] {
	// Angular re-exports all presets from its theming module
	if (options.platform === "angular") {
		return [];
	}

	const lines: string[] = [];

	if (options.includeTypography) {
		lines.push(`@use '${TYPOGRAPHY_PRESETS_PATH}' as *;`);
	}

	if (options.includeElevations) {
		lines.push(`@use '${ELEVATIONS_PRESETS_PATH}' as *;`);
	}

	return lines;
}

/**
 * Options for generating a palette function call.
 */
export interface PaletteCodeOptions {
	/** Primary brand color */
	primary: string;
	/** Secondary/accent color (required by Sass palette function) */
	secondary: string;
	/** Surface/background color (required by Sass palette function) */
	surface: string;
	/** Gray base color */
	gray?: string;
	/** Info state color */
	info?: string;
	/** Success state color */
	success?: string;
	/** Warning state color */
	warn?: string;
	/** Error state color */
	error?: string;
	/** Theme variant (affects surface default) */
	variant?: ThemeVariant;
	/** Variable name for the palette (without $) */
	variableName?: string;
	/** Whether to use inline color values or reference Sass variables */
	useVariableReferences?: boolean;
}

/**
 * Result from generating palette code.
 */
export interface PaletteCodeResult {
	/** Lines for color variable declarations (if useVariableReferences is true) */
	colorVariables: string[];
	/** Lines for the palette() function call */
	paletteDefinition: string[];
	/** The full variable name (with $) */
	variableName: string;
}

/**
 * Generate the palette() function call code.
 * Returns an object with code lines that can be joined or embedded in other code.
 *
 * @example
 * // Basic usage - returns lines for palette definition
 * const result = generatePaletteCode({ primary: '#2ab759' });
 * // result.paletteDefinition: ['$custom-light-palette: palette(', '  $primary: #2ab759,', '  $surface: white', ');']
 *
 * @example
 * // With variable references (for use in theme generators)
 * const result = generatePaletteCode({
 *   primary: '#2ab759',
 *   useVariableReferences: true,
 *   variableName: 'my-palette'
 * });
 * // Uses $primary-color, $secondary-color references
 */
export function generatePaletteCode(
	options: PaletteCodeOptions,
): PaletteCodeResult {
	const variant = options.variant ?? "light";
	const varName = options.variableName
		? `$${options.variableName}`
		: `$custom-${variant}-palette`;

	const colorVariables: string[] = [];
	const paletteArgs: string[] = [];

	// Primary, secondary, and surface are required by the Sass palette() function
	if (options.useVariableReferences) {
		// Generate color variable declarations and reference them in palette
		colorVariables.push(`$primary-color: ${options.primary};`);
		paletteArgs.push("$primary: $primary-color");

		colorVariables.push(`$secondary-color: ${options.secondary};`);
		paletteArgs.push("$secondary: $secondary-color");

		colorVariables.push(`$surface-color: ${options.surface};`);
		paletteArgs.push("$surface: $surface-color");

		if (options.gray) {
			colorVariables.push(`$gray-color: ${options.gray};`);
			paletteArgs.push("$gray: $gray-color");
		}
	} else {
		// Use inline color values - all three required
		paletteArgs.push(`$primary: ${options.primary}`);
		paletteArgs.push(`$secondary: ${options.secondary}`);
		paletteArgs.push(`$surface: ${options.surface}`);
		if (options.gray) paletteArgs.push(`$gray: ${options.gray}`);
	}

	// Additional color options (always inline)
	if (options.info) paletteArgs.push(`$info: ${options.info}`);
	if (options.success) paletteArgs.push(`$success: ${options.success}`);
	if (options.warn) paletteArgs.push(`$warn: ${options.warn}`);
	if (options.error) paletteArgs.push(`$error: ${options.error}`);

	const paletteDefinition = [
		`${varName}: palette(`,
		...paletteArgs.map(
			(arg, i) => `  ${arg}${i < paletteArgs.length - 1 ? "," : ""}`,
		),
		");",
	];

	return {
		colorVariables,
		paletteDefinition,
		variableName: varName,
	};
}

/**
 * Options for generating a typography mixin call.
 */
export interface TypographyCodeOptions {
	/** Font family string */
	fontFamily: string;
	/** Type scale variable name (with $) */
	typeScaleVar: string;
	/** Indentation for the mixin call */
	indent?: string;
}

/**
 * Generate the typography() mixin call code.
 * Returns an array of lines that can be joined or embedded in other code.
 */
export function generateTypographyCode(
	options: TypographyCodeOptions,
): string[] {
	const indent = options.indent ?? "";
	return [
		`${indent}@include typography(`,
		`${indent}  $font-family: ${quoteFontFamily(options.fontFamily)},`,
		`${indent}  $type-scale: ${options.typeScaleVar}`,
		`${indent});`,
	];
}

/**
 * Options for generating an elevations mixin call.
 */
export interface ElevationsCodeOptions {
	/** Elevations variable name (with $) */
	elevationsVar: string;
	/** Indentation for the mixin call */
	indent?: string;
}

/**
 * Generate the elevations() mixin call code.
 * Returns an array of lines that can be joined or embedded in other code.
 */
export function generateElevationsCode(
	options: ElevationsCodeOptions,
): string[] {
	const indent = options.indent ?? "";
	return [`${indent}@include elevations(${options.elevationsVar});`];
}

// ============================================================================
// CUSTOM PALETTE CODE GENERATION
// ============================================================================

/**
 * Options for generating a custom handmade palette.
 */
export interface CustomPaletteCodeOptions {
	/** Target platform (affects import statements) */
	platform?: Platform;
	/** Theme variant (light or dark) */
	variant?: ThemeVariant;
	/** Variable name for the palette (without $ prefix) */
	variableName?: string;
	/** Surface color for gray shades generation */
	surfaceColor?: string;
	/** Color definitions for all palette groups */
	colors: {
		primary: ColorDefinition;
		secondary: ColorDefinition;
		surface: ColorDefinition;
		gray: GrayDefinition;
		info: ColorDefinition;
		success: ColorDefinition;
		warn: ColorDefinition;
		error: ColorDefinition;
	};
}

/**
 * Generates Sass code for a custom handmade palette.
 *
 * This function creates a Sass map palette structure that can use either:
 * - The `shades()` function for auto-generating shades from a base color
 * - Explicit shade maps with manual control over each shade value
 *
 * @example
 * // Generate palette with mixed modes
 * const lines = generateCustomPaletteCode({
 *   variant: 'light',
 *   variableName: 'my-brand',
 *   surfaceColor: '#fafafa',
 *   colors: {
 *     primary: { mode: 'explicit', shades: { '50': '#e6eff8', ... } },
 *     secondary: { mode: 'shades', baseColor: '#f7bd32' },
 *     // ...
 *   }
 * });
 */
export function generateCustomPaletteCode(
	options: CustomPaletteCodeOptions,
): string[] {
	const variant = options.variant ?? "light";
	const varName = options.variableName ?? `custom-${variant}`;

	const lines: string[] = [];
	lines.push(`$${varName}-palette: (`);

	const colorGroups: Array<{
		name: string;
		def: ColorDefinition | GrayDefinition;
		shades: readonly string[];
		isGray: boolean;
	}> = [
		{
			name: "primary",
			def: options.colors.primary,
			shades: ALL_COLOR_SHADES,
			isGray: false,
		},
		{
			name: "secondary",
			def: options.colors.secondary,
			shades: ALL_COLOR_SHADES,
			isGray: false,
		},
		{
			name: "gray",
			def: options.colors.gray,
			shades: SHADE_LEVELS,
			isGray: true,
		},
		{
			name: "surface",
			def: options.colors.surface,
			shades: ALL_COLOR_SHADES,
			isGray: false,
		},
		{
			name: "info",
			def: options.colors.info,
			shades: ALL_COLOR_SHADES,
			isGray: false,
		},
		{
			name: "success",
			def: options.colors.success,
			shades: ALL_COLOR_SHADES,
			isGray: false,
		},
		{
			name: "warn",
			def: options.colors.warn,
			shades: ALL_COLOR_SHADES,
			isGray: false,
		},
		{
			name: "error",
			def: options.colors.error,
			shades: ALL_COLOR_SHADES,
			isGray: false,
		},
	];

	for (let i = 0; i < colorGroups.length; i++) {
		const { name, def, shades, isGray } = colorGroups[i];
		// Always add comma after each color group since _meta comes last
		const needsComma = true;

		if (def.mode === "shades") {
			// Use shades() function
			const shadesListStr = shades.map((s) => `'${s}'`).join(", ");
			lines.push(`  '${name}': shades(`);
			lines.push(`    '${name}',`);
			lines.push(`    ${def.baseColor},`);
			// Add surface parameter for gray to ensure proper contrast
			if (isGray && options.surfaceColor) {
				lines.push(`    (${shadesListStr}),`);
				lines.push(`    ${options.surfaceColor}`);
			} else {
				lines.push(`    (${shadesListStr})`);
			}
			lines.push(`  )${needsComma ? "," : ""}`);
		} else {
			// Explicit shade map
			lines.push(`  '${name}': (`);

			for (let j = 0; j < shades.length; j++) {
				const shade = shades[j];
				const color = def.shades[shade as keyof typeof def.shades];
				const contrast =
					def.contrastOverrides?.[shade as keyof typeof def.contrastOverrides];
				const isLastShade = j === shades.length - 1;

				// Shade value
				lines.push(`    '${shade}': ${color},`);
				// Contrast (explicit or adaptive-contrast)
				const contrastValue = contrast ?? `adaptive-contrast(${color})`;
				lines.push(`    '${shade}-contrast': ${contrastValue},`);
				// Raw value (exact color, no wrapping)
				lines.push(`    '${shade}-raw': ${color}${isLastShade ? "" : ","}`);
			}

			lines.push(`  )${needsComma ? "," : ""}`);
		}
	}

	// Add metadata
	lines.push(`  '_meta': (`);
	lines.push(`    'variant': ${variant}`);
	lines.push("  )");
	lines.push(");");

	return lines;
}
